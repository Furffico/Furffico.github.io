[{"content":"starship 是使用Rust编写的轻量且迅速的终端提示符程序，其功能和作用与Oh My Zsh 相似，但是相比于Oh My Zsh，starship具有以下优点：\nstarship是跨平台跨终端的，其支持Bash、Zsh、Fish等十几种终端，甚至包括Windows的PowerShell与cmd； 使用编译型语言Rust编写的starship在运行速度上优于基于shell script的Oh My Zsh； starship的自定义配置方法比Oh My Zsh简单。 先上图，以下是我所习惯的配置的效果图。除当前用户、hostname和当前工作路径外，starship还显示了git状态、相关软件的版本、进程的返回码、运行时间、已用内存/虚拟内存和当前时间等信息。starfish是通过当前工作目录下的文件名判断应当展示哪些模组的，所以当我创建文件之后提示符上也就多出了相关软件的信息。\n下文将简述starship的安装方法，并给出我的配置文件。\n安装 本文仅适用于在Linux下的bash和zsh终端安装starship，在其它终端的安装方法请参见starship的官方文档。\n首先使用官方脚本在Linux系统内安装starship程序：\n1 $ curl -sS https://starship.rs/install.sh | sh 这时如果在终端输入starship -V能看到starship的版本信息，就说明程序安装成功了。\n然后需要配置终端程序，使其能使用starship作为提示符。在~/.bashrc（bash终端）或~/.zshrc（zsh终端）内加入这一行即可：\n1 eval \u0026#34;$(starship init bash)\u0026#34; 配置 starship的配置文件是~/.config/starship.toml，你也可以通过设置环境变量STARSHIP_CONFIG改变此文件的位置。在终端输入starship config可以直接打开该文件。\n由后缀名可知，starship的配置文件为TOML文件，遵守TOML语法，关于TOML语法本文就不赘述了，若需要了解详情请移步TOML官网。\nstarship是分模块的结构，starship生成的提示符中的每一个部分都对应starship的一个模块，你可以使用starship explain指令查看各模块的说明及其运行时间，例如以我当前的配置输入该命令后效果如下：\n关于如何自定义配置，starship的官方文档已经写的很完善了，参见 https://starship.rs/zh-CN/config/。\nstarship在官方文档里已经给出了一些预设，你可以以你喜欢的预设为基础进行定制，例如我的配置就是在Bracketed Segments和Nerd Font Symbols预设之上按照自己的习惯所做的更改。我的starship.toml如下：\n另外，使用Nerd Font Symbols需要Nerd Font，请前往 https://www.nerdfonts.com/font-downloads 下载你习惯的字体对应的图标字体，并在虚拟终端中将其设为默认字体。\n问题 在使用Anaconda管理Python的虚拟环境时，Anaconda会自动在提示符前加上当前虚拟环境的名称，如(base)，这与starship冲突了（且starship的conda模块提供了相同的功能），因此需要使用如下指令禁用Anaconda的这个功能。\n1 $ conda config --set changeps1 False ","date":"2023-01-06T16:24:31+08:00","image":"https://files.furffisite.link/blogimg/20230109230402-9ec5accbc75f863015a4dca68f9f9870-cc3be.jpg","permalink":"https://blog.furffisite.link/p/use-starship/","title":"使用starship定制终端提示符"},{"content":" 今天在QQ看到一张图，这张图在预览下看到的和查看图片时看到的内容不一样。虽然不是第一次见这种图了，但是今天在摸鱼的时候无事可做，就研究了一下它的原理。\n这张图是这样的：左图为它在聊天界面的样子，典型的吃🍑场景，点开大图之后看到的却是右图的样子（笑）。 中间的图片为嵌入的原图，如果您开启了暗色模式（桌面端可以在页面右下角切换），您看到中图的应该和右图一样，反之则和左图一样。 原图可以在这里获取。\n原理 这种图的原理并不难猜，肯定利用了png图片的透明度通道，使其在不同背景色下能呈现出不同的效果。下面求解一下它是怎么制作出来的： （因为这里只涉及图像的像素变换，为简化表示，以下的每个变量都表示单个像素单个通道的值，且定义域为$[0,1]$.）\n设在聊天界面看到的图像（表图）灰度为$c$，点开大图后看到的图像（里图）为$h$，待求量为生成的图像的灰度$g$与透明度$a$。\n在聊天界面的图像是目标图像和白色背景的混合，也就是$$(1-a) + g\\cdot a = c.$$ 点开大图后是目标图像和黑色背景的混合，即$$0+g\\cdot a = h.$$\n解出来就是$$a=1+h-c,~g=h/a.$$\n又因为解需要满足$a,g\\in(0,1]$，所以$c$和$h$需要满足不等式$$h\\le c\u0026lt;1+h$$ 右侧当且仅当$c=1,~h=0$时不成立。\n实现 这个程序实现起来没有什么难度，python代码如下（需要Pillow与numpy）。需要注意的是，为了满足上面的不等式，在程序中需要重新分配两张原图的灰度的范围。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import numpy as np from PIL import Image # 读取图片+转灰度 cover = Image.open(\u0026#34;./cover.png\u0026#34;).convert(\u0026#34;L\u0026#34;) hidden = Image.open(\u0026#34;./hidden.png\u0026#34;).convert(\u0026#34;L\u0026#34;) assert cover.size == hidden.size cover = np.asarray(cover) hidden = np.asarray(hidden) # 按照约束条件调整像素范围 cover_min, cover_max = cover.min(), cover.max() hidden_min, hidden_max = hidden.min(), hidden.max() cd = cover_max - cover_min hd = hidden_max - hidden_min divide_portion = hd/(hd*1.0+cd) cover_f = (cover-cover_min)*1.0/cd * (1-divide_portion-1/255) + divide_portion hidden_f = (hidden-hidden_min)*1.0/hd * divide_portion # 计算 alpha = 1-cover_f+hidden_f gray = hidden_f/alpha alpha = (alpha*255).astype(np.uint8) gray = (gray*255).astype(np.uint8) result = np.stack([gray,gray,gray,alpha], axis=-1) # 保存结果 img = Image.fromarray(result) img.save(\u0026#34;./output.png\u0026#34;) 这是随手抓的两张黑白表情包做出来的效果，顺序和上面的展示一样，您可以通过切换暗色模式查看效果：\n注：在QQ发送此类图片时，一定要选择发送原图，否则QQ可能会在压缩过程中去掉透明度通道，导致其失效。\n","date":"2023-01-03T23:51:54+08:00","image":"https://files.furffisite.link/blogimg/20230104022542-b692e6e89157626a929575a0b97e5583-3e819.jpg","permalink":"https://blog.furffisite.link/p/qq-duplicity-image/","title":"利用透明度通道制作QQ内表里不一的图片"},{"content":"如何在$\\LaTeX$中将超出文本宽度的浮动体（表格/图片）居中？这个问题我曾多次遇到过，但是没有一次记得怎么解决，每次都需要谷歌。今天也碰到了这个情况，因此将解决方案记录备忘。\n我看到的最优雅的解决方案出自$\\TeX$的StackExchange中的这篇回答。只要在浮动体内减少左右边距即可，也就是下列示例的第3-4行：\n1 2 3 4 5 6 7 \\begin{figure}[t] \\centering \\addtolength{\\leftskip}{-2cm} % increase (absolute) value if needed \\addtolength{\\rightskip}{-2cm} \\includegraphics[width=1.2\\textwidth]{image} \\caption{example}\\label{fig:example} \\end{figure} 效果如下图：\n","date":"2022-12-24T12:38:21+08:00","permalink":"https://blog.furffisite.link/p/latex-widefloat-centering/","title":"如何将LaTeX内超出文本宽度的浮动体居中"},{"content":"前言 今天想给我这个博客加一张图片，但是把图片文件和博客的文章放在一起，内容管理比较麻烦，并且会增大git仓库的体积。因此我就想到了使用图床分流博客中的图片。\n在网上搜索了一些图床服务，发现国内免费的图床服务要么访问慢（因为源服务器在海外），要么不稳定（存在关站/被墙或者转为付费的可能），而国外著名的图床imgur在国内也处于半墙的状态。于是就想到了使用云计算厂商提供的OSS对象存储服务，虽然收费但是对于我这种有计划长时间运营下去的博客而言，图床的可靠性是最重要的。我可不想因为图站挂掉导致我在未来的某一天要重新找到再上传这些图片。\n在看了阿里云、腾讯云和华为云三家之后我选择了阿里云，因为阿里云有每月5GB存储和外网流量的的免费额度，请求费用也就每万次一毛钱，对于我这种刚开的小站而言，存储、流量和请求都不会很大（如果被攻击那就是另一回事了，还望您手下留情）。关于阿里云的定价详情可以查看阿里云的价格计算器。\n然后我就按照这篇博文的步骤搭建了图床，途中遇到了原文没有提及的许多问题，所以在这里记录一下完整的步骤、我遇到的问题与解决方案。\n主要操作流程 创建Bucket：开通OSS并创建Bucket。创建Bucket时选择海外的地域（如果在别的地域没有服务器的话，建议使用香港），存储类型选择标准存储即可，读写权限一定要选择私有，其余的附加服务按需启用（有的得加钱）。创建完成后可以向Bucket中上传一张图片作为测试图。\n配置访问权限：进入权限控制 -\u0026gt; Bucket授权策略面板，添加授权，配置如下图。\nIP字段填写的是CloudFlare的节点IP，列表如下（来自知乎专栏）：\n173.245.48.0/20,103.21.244.0/22,103.22.200.0/22,103.31.4.0/22, 141.101.64.0/18,108.162.192.0/18,190.93.240.0/20,188.114.96.0/20, 197.234.240.0/22,198.41.128.0/17,162.158.0.0/15,104.16.0.0/12, 172.64.0.0/13,131.0.72.0/22,103.21.244.0/22,103.22.200.0/22, 103.31.4.0/22,104.16.0.0/12,108.162.192.0/18,131.0.72.0/22, 141.101.64.0/18,162.158.0.0/15,172.64.0.0/13,173.245.48.0/20, 188.114.96.0/20,190.93.240.0/20,197.234.240.0/22,198.41.128.0/17 配置CDN：在CloudFlare的DNS管理面板添加CNAME记录，目标设为Bucket的域名（可以在Bucket的概览界面找到），代理状态设为已代理，否则CDN不起作用。 绑定域名：在阿里云的Bucket配置-\u0026gt;域名管理界面绑定你刚设置的域名，这时阿里云需要验证域名的所有权，按照其所说的在CloudFlare的DNS管理处添加指定TXT记录即可。\n创建并添加证书：在CloudFlare的配置面板的SSL/TLS-\u0026gt;源服务器处，选择创建证书。创建之后会告诉你源证书与私钥，这个界面暂时不要动。打开刚才在阿里云控制台绑定证书的界面，选择证书托管，并上传SSL证书，这时会打开SSL证书的界面，选择上传证书，并将CloudFlare给出的源证书和密钥复制到上传证书的对应字段处（证书名字随便设），然后确定。这时切换回上传SSL证书，应该就能在证书名称处看到刚刚设置的证书名字了（看不到的话重开一下这个界面试试），选中，然后点下方的上传即可。\n这时就已经可以通过你设置的域名访问刚才上传的测试图片了。假如测试图片filename.jpg存储在OSS的folder文件夹下，你设置的域名为image.example.org，则访问路径为https://image.example.org/folder/filename.jpg。\n安全性配置 跨域设置：在阿里云OSS的数据安全-\u0026gt;跨域设置中创建跨域规则，来源设置为你的网站的地址。为了能让网站在本地测试时也能正常展示图片，建议同时添加localhost:*与127.0.0.1:*。 防盗链设置：和跨域设置类似。不同之处在于Referer是包含请求协议的，所以类似于example.org或localhost:*等不包括协议的配置是无效的，需要改为https://example.com或*://localhost:*；需要注意的是*.example.org虽然是有效的，但是没有指定https协议，安全起见最好改为https://*.example.org。 PicGo 配置 PicGo是一款快速上传图片到图床，并自动复制图片URL到剪贴板的工具，你可以在Github的release页获取该程序。\n权限设置：在阿里云的权限控制 -\u0026gt; Bucket授权策略面板新增授权，配置如下： 如果当前没有RAM子帐号，请点击右上角头像-\u0026gt;访问控制，然后在左侧的身份管理-\u0026gt;用户处创建一个子帐号。创建完成后在子帐号的详情页创建AccessKey，得到AccessKey的KeyID与KeySecret，保留备用。\n上传配置：打开PicGo主界面，在图床设置-\u0026gt;阿里云OSS内填写对应的表单项。“KeyID”与“KeySecret”即刚才获取的子帐号AccessKey的KeyID与KeySecret，“设定Bucket”为Bucket的名称，“存储区域”为Bucket所在区域（与Bucket域名内的值统一，例如oss-cn-hongkong），自定义域名填写你设置的域名，其余两项按需填写即可。配置完成后点击确定并设为默认图床。\n注：如果你使用的桌面环境是KDE Plasma，可能需要在PicGo设置内打开“使用内置剪贴板上传”一项，否则无法正常从剪贴板直接上传图片。我使用的Linux发行版是KDE Neon，其它发行版/桌面环境/操作系统尚未测试。\n","date":"2022-12-20T01:48:09+08:00","image":"https://files.furffisite.link/blogimg/202212251307965.jpg","permalink":"https://blog.furffisite.link/p/imagebed-oss-conf/","title":"使用阿里云OSS存储服务+CloudFlare配置图床"}]